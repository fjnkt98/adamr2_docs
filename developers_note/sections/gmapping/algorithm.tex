\documentclass[{../../master}]{subfiles}
\graphicspath{{../../}}  % 個別コンパイル時の画像パスを解決する

\begin{document}

\section{GMappingのアルゴリズムの概要}
\label{sec:gmapping_algorithm}

GMappingは格子ベースの地図を扱うベイズフィルタ系のSLAMアルゴリズムです．
FastSLAM2.0のアプローチを採用しており，スキャンマッチングによってオドメトリを修正することにより，少ないパーティクルでも良好な推定を行うことができるのが特徴です．

\subsection{GMappingが扱う問題}

\subsubsection{求める解}

ロボットの初期姿勢$\bm{x}_{0}$，観測の時系列リスト$z_{1:t}$，オドメトリ情報$u_{1:t}$が得られたとき，ロボットの軌跡$\bm{x}_{1:t}$と地図$m$の結合確率分布を求めます．
\footnote{論文\cite{Gmapping}に書かれている数式と少し異なりますが，表している事象は同じです．}

\begin{equation}
  p(\bm{x_{1:t}}, m \mid \bm{x}_{0}, z_{1:t}, u_{1:t})
  \label{eq:target_distribution}
\end{equation}

ここで，$\bm{x}_{t}$はロボットの姿勢(Pose)を表すベクトルであり，$\bm{x}_{x} = (x_{t}, y_{t}, \theta_{t})^T$です．
$z_{t}$は時刻$t$で得られた観測の情報で，GMappingではスキャンデータが用いられます．
$u_{t}$は，時刻$t-1$から時刻$t$までにロボットが移動した距離を，ホイールオドメトリで求めた情報です．
また，$1:t$の表記は時刻$1$から時刻$t$までの時系列のリストを表しています．

SLAMの目的は式\ref{eq:target_distribution}の確率分布を求めることにあります．
確率分布を求めることができれば，確率密度が一番高いところにロボットがいるのが尤もらしいと言えるため，結果的にロボットの姿勢を求めることに繋がります．

しかし，式\ref{eq:target_distribution}の確率分布がどのような形状をしているのかは誰にもわかりません．
従って，式\ref{eq:target_distribution}を直接求めることはほぼ不可能に近い難問になります．
そのため，何らかの近似や仮定を用いることによって確率分布を求めることになります．
その近似手法の1つが，GMappingでも用いられているパーティクルフィルタです．

パーティクルフィルタは連続な関数である確率分布を，重みを持ったパーティクルの集合として離散的に近似する手法です．
確率分布の内の確率密度が高い部分が，重みの大きいパーティクルに対応します．
パーティクルの数を無限大に近づけると元の確率分布に近づきます．

% TODO: パーティクルフィルタの概要の説明．1次元のグラフかなんかを書いて説明する

GMappingではRao-Blackwellizationと呼ばれる因数分解を適用して，式\ref{eq:target_distribution}の確率分布を分解しています．

\begin{equation}
  \begin{split}
    &p(\bm{x_{1:t}}, m \mid \bm{x}_{0}, z_{1:t}, u_{1:t}) \\
    &= p(m \mid \bm{x}_{1:t}, \bm{x}_{0}, u_{1:t}, z_{1:t}) \cdot p(\bm{x}_{1:t} \mid \bm{x}_{0}, u_{1:t}, z_{1:t}) \\
    &= p(m \mid \bm{x}_{0:t}, z_{1:t}) \cdot p(\bm{x}_{1:t} \mid z_{1:t}, u_{1:t})
  \end{split}
  \label{eq:rao_blackwellized_distribution}
\end{equation}

式\ref{eq:target_distribution}にRao-Blackwellizationを適用したのが式\ref{eq:rao_blackwellized_distribution}です．
式\ref{eq:rao_blackwellized_distribution}を見ると，この問題はロボットの姿勢の分布$p(\bm{x}_{1:t} \mid z_{1:t}, u_{1:t})$を求める問題と，地図$p(m \mid \bm{x}_{0:t}, z_{1:t})$を求める問題に分解して考えられるようになります．

\subsubsection{SLAMにおける用語}

式\ref{eq:target_distribution}で示すような，SLAMで求める確率分布を「目標分布」または「信念(信念分布)」と呼びます．\cite{上田2019}
パーティクルフィルタを含むベイズフィルタの演算は単純なもので，まずロボットの移動の情報をもとに時刻$t-1$の信念分布を遷移させ，その後センサ等の観測情報を用いて時刻$t$の信念を確定させる，という処理を繰り返します．

ロボットの移動の情報をもとに信念分布を遷移させるときに使う確率モデルを「移動モデル」\cite{thrun2005probabilistic}もしくは「状態遷移モデル」\cite{上田2019}と呼びます．
状態遷移モデルはロボットの移動に含まれるノイズやバイアスを確率的に扱うモデルで，式\ref{eq:motion_model}で表されます．
また，状態遷移モデルによって遷移させられた信念分布を「提案分布」もしくは「事前分布」と呼びます．
Probabilistic Roboticsでは，状態遷移モデルの種類として速度動作モデル(\textsf{motion\_model\_velocity})とオドメトリ動作モデル(\textsf{motion\_model\_odometry})が紹介されています．

\begin{equation}
  p(\bm{x}_{t} \mid \bm{x}_{t-1}, u_{t})
  \label{eq:motion_model}
\end{equation}

状態遷移モデルによって信念分布を遷移した後，観測情報を用いて時刻$t$の信念分布を確定させる際に使う確率モデルを「計測モデル」\cite{thrun2005probabilistic}「観測モデル」\cite{上田2019}と呼びます．
観測モデルは式\ref{eq:measurement_model}で表されます．
提案分布に観測モデルを適用してできた分布を「目標分布」もしくは「事後分布」と呼びます．
Probabilistic Roboticsでは，LiDAR等のレーザーセンサのための観測モデルの種類としてビームモデル(\textsf{beam\_range\_finder\_model})と尤度場モデル(\textsf{likelihood\_field\_model})が紹介されています．

\begin{equation}
  p(z_{t} \mid \bm{x}_{t}, m)
  \label{eq:measurement_model}
\end{equation}

\subsection{問題の定式化}

パーティクルフィルタにおいて，$i$番目のパーティクルの重み$w^{(i)}$は式\ref{eq:particle_weight_equation}で更新されます．

\begin{equation}
  w^{(i)} = \frac{p(\bm{x}_{1:t}^{(i)} \mid z_{1:t}, u_{1:t})}{\pi(\bm{x}_{1:t}^{(i)} \mid z_{1:t}, u_{1:t})}
  \label{eq:particle_weight_equation}
\end{equation}

式\ref{eq:particle_weight_equation}右辺の分子は事後分布，分母は提案分布です．
事後分布と提案分布の差が小さい程フィルタの性能は上がりますが，提案分布$\pi$が事後分布と一致することはまずありません．
また，式\ref{eq:particle_weight_equation}のままだと新しい観測が得られる度に各パーティクルの軌跡の重みを評価しなければならないため，時間が経過するにつれて計算負荷は増大していってしまいます．
ここで，提案分布が式\ref{eq:proposal_assumption}に従うと仮定します．

\begin{equation}
  \pi(\bm{x}_{1:t} \mid z_{1:t}, u_{1:t}) = \pi(\bm{x}_{t} \mid \bm{x}_{1:t-1}, z_{1:t}, u_{1:t}) \cdot \pi(\bm{x}_{1:t-1} \mid z_{1:t-1}, u_{1:t-1})
  \label{eq:proposal_assumption}
\end{equation}

式\ref{eq:proposal_assumption}を使って式\ref{eq:particle_weight_equation}を逐次式に変換すると，

\begin{equation}
  \begin{split}
    &w^{(i)} = \frac{p(\bm{x}_{1:t}^{(i)} \mid z_{1:t}, u_{1:t})}{\pi(\bm{x}_{1:t}^{(i)} \mid z_{1:t}, u_{1:t})} \\
    &= \eta \frac{p(z_{1:t} \mid \bm{x}_{1:t}^{(i)}, z_{1:t-1}) p(\bm{x}_{t}^{(i)} \mid \bm{x}_{t-1}^{(i)}, u_{t})}{\pi(\bm{x}_{t}^{(i)} \mid \bm{x}_{1:t-1}^{(i)}, z_{1:t}, u_{1:t})} \cdot \frac{p(\bm{x}_{1:t-1}^{(i)} \mid z_{1:t-1}, u_{1:t-1})}{\pi(\bm{x}_{1:t-1}^{(i)} \mid z_{1:t-1}, u_{1:t-1})} \\
    &= \eta \frac{p(z_{1:t} \mid \bm{x}_{t}^{(i)}, m_{t-1}^{(i)}) p(\bm{x}_{t}^{(i)} \mid \bm{x}_{t-1}^{(i)}, u_{t})}{\pi(\bm{x}_{t}^{(i)} \mid \bm{x}_{1:t-1}^{(i)}, z_{1:t}, u_{1:t}}) w_{t-1}^{(i)}
  \end{split}
  \label{eq:sequential_particle_weight_equation}
\end{equation}

\noindent
となります．ただし，$\eta$は式\ref{eq:sequential_particle_weight_equation}の2段目でベイズの定理を適用して確率分布を分解したときに出てきた正規化因子です．

式\ref{eq:sequential_particle_weight_equation}を使ってパーティクルを更新するためには，提案分布$\pi$からドローしなければなりません．
パーティクルフィルタの性能は提案分布$\pi$で決まり，$\pi$が目標分布に近ければフィルタの性能は向上します．

FastSLAM1.0のような従来型のアルゴリズムでは，この提案分布$\pi$には状態遷移モデル$p(\bm{x}_{t} \mid \bm{x}_{t-1}, u_{t})$が使用されます．
提案分布に状態遷移モデルを使うと，パーティクルの重みの演算が観測モデル$p(z_{t} \mid m, \bm{x}_{t})$だけで行えます．
実際，式\ref{eq:sequential_particle_weight_equation}の$\pi$に状態遷移モデルを代入すると，式\ref{eq:sequential_weight_equation_fastslam1.0}のようになります．

\begin{equation}
  \begin{split}
    &w_{t}^{(i)} = \eta \frac{p(z_{1:t} \mid \bm{x}_{t}^{(i)}, m_{t-1}^{(i)}) p(\bm{x}_{t}^{(i)} \mid \bm{x}_{t-1}^{(i)}, u_{t})}{\pi(\bm{x}_{t}^{(i)} \mid \bm{x}_{1:t-1}^{(i)}, z_{1:t}, u_{1:t}}) w_{t-1}^{(i)} \\
    &= \eta \frac{p(z_{1:t} \mid \bm{x}_{t}^{(i)}, m_{t-1}^{(i)}) p(\bm{x}_{t}^{(i)} \mid \bm{x}_{t-1}^{(i)}, u_{t})}{p(\bm{x}_{t}^{(i)} \mid \bm{x}_{1:t-1}^{(i)}, z_{1:t}, u_{1:t}}) w_{t-1}^{(i)} \\
    &= \eta p(z_{1:t} \mid \bm{x}_{t}^{(i)}, m_{t-1}^{(i)}) w_{t-1}^{(i)}
  \end{split}
  \label{eq:sequential_weight_equation_fastslam1.0}
\end{equation}

\subsection{オドメトリ状態遷移モデル}

\subsection{レーザービームの尤度場モデル}

\subsection{リサンプリングアルゴリズム}

\end{document}