\documentclass[{../../master}]{subfiles}
\graphicspath{{../../}}  % 個別コンパイル時の画像パスを解決する

\begin{document}

\section{GMappingのアルゴリズムの概要}
\label{sec:gmapping_algorithm}

GMappingは格子ベースの地図を扱うベイズフィルタ系のSLAMアルゴリズムです．
FastSLAM2.0のアプローチを採用しており，スキャンマッチングによってオドメトリを修正することにより，少ないパーティクルでも良好な推定を行うことができるのが特徴です．

\subsection{GMappingが扱う問題}

\subsubsection{求める解}

ロボットの初期姿勢$\bm{x}_{0}$，観測の時系列リスト$z_{1:t}$，オドメトリ情報$u_{1:t}$が得られたとき，ロボットの軌跡$\bm{x}_{1:t}$と地図$m$の結合確率分布を求めます．
\footnote{論文\cite{Gmapping}に書かれている数式と少し異なりますが，表している事象は同じです．}

\begin{equation}
  p(\bm{x_{1:t}}, m \mid \bm{x}_{0}, z_{1:t}, u_{1:t})
  \label{eq:target_distribution}
\end{equation}

ここで，$\bm{x}_{t}$はロボットの姿勢(Pose)を表すベクトルであり，$\bm{x}_{x} = (x_{t}, y_{t}, \theta_{t})^T$です．
$z_{t}$は時刻$t$で得られた観測の情報で，GMappingではスキャンデータが用いられます．
$u_{t}$は，時刻$t-1$から時刻$t$までにロボットが移動した距離を，ホイールオドメトリで求めた情報です．
また，$1:t$の表記は時刻$1$から時刻$t$までの時系列のリストを表しています．

SLAMの目的は式\ref{eq:target_distribution}の確率分布を求めることにあります．
確率分布を求めることができれば，確率密度が一番高いところにロボットがいるのが尤もらしいと言えるため，結果的にロボットの姿勢を求めることに繋がります．

しかし，式\ref{eq:target_distribution}の確率分布がどのような形状をしているのかは誰にもわかりません．
従って，式\ref{eq:target_distribution}を直接求めることはほぼ不可能に近い難問になります．
そのため，何らかの近似や仮定を用いることによって確率分布を求めることになります．
その近似手法の1つが，GMappingでも用いられているパーティクルフィルタです．

パーティクルフィルタは連続な関数である確率分布を，重みを持ったパーティクルの集合として離散的に近似する手法です．
確率分布の内の確率密度が高い部分が，重みの大きいパーティクルに対応します．
パーティクルの数を無限大に近づけると元の確率分布に近づきます．

% TODO: パーティクルフィルタの概要の説明．1次元のグラフかなんかを書いて説明する

GMappingではRao-Blackwellizationと呼ばれる因数分解を適用して，式\ref{eq:target_distribution}の確率分布を分解しています．

\begin{equation}
  \begin{split}
    &p(\bm{x_{1:t}}, m \mid \bm{x}_{0}, z_{1:t}, u_{1:t}) \\
    &= p(m \mid \bm{x}_{1:t}, \bm{x}_{0}, u_{1:t}, z_{1:t}) \cdot p(\bm{x}_{1:t} \mid \bm{x}_{0}, u_{1:t}, z_{1:t}) \\
    &= p(m \mid \bm{x}_{0:t}, z_{1:t}) \cdot p(\bm{x}_{1:t} \mid z_{1:t}, u_{1:t})
  \end{split}
  \label{eq:rao_blackwellized_distribution}
\end{equation}

式\ref{eq:target_distribution}にRao-Blackwellizationを適用したのが式\ref{eq:rao_blackwellized_distribution}です．
式\ref{eq:rao_blackwellized_distribution}を見ると，この問題はロボットの姿勢の分布$p(\bm{x}_{1:t} \mid z_{1:t}, u_{1:t})$を求める問題と，地図$p(m \mid \bm{x}_{0:t}, z_{1:t})$を求める問題に分解して考えられるようになります．

\subsubsection{SLAMにおける用語}

式\ref{eq:target_distribution}で示すような，SLAMで求める確率分布を「目標分布」または「信念(信念分布)」と呼びます．\cite{上田2019}
パーティクルフィルタを含むベイズフィルタの演算は単純なもので，まずロボットの移動の情報をもとに時刻$t-1$の信念分布を遷移させ，その後センサ等の観測情報を用いて時刻$t$の信念を確定させる，という処理を繰り返します．

ロボットの移動の情報をもとに信念分布を遷移させるときに使う確率モデルを「移動モデル」\cite{thrun2005probabilistic}もしくは「状態遷移モデル」\cite{上田2019}と呼びます．
状態遷移モデルはロボットの移動に含まれるノイズやバイアスを確率的に扱うモデルで，式\ref{eq:motion_model}で表されます．
また，状態遷移モデルによって遷移させられた信念分布を「提案分布」もしくは「事前分布」と呼びます．
Probabilistic Roboticsでは，状態遷移モデルの種類として速度動作モデル(\textsf{motion\_model\_velocity})とオドメトリ動作モデル(\textsf{motion\_model\_odometry})が紹介されています．

\begin{equation}
  p(\bm{x}_{t} \mid \bm{x}_{t-1}, u_{t})
  \label{eq:motion_model}
\end{equation}

状態遷移モデルによって信念分布を遷移した後，観測情報を用いて時刻$t$の信念分布を確定させる際に使う確率モデルを「計測モデル」\cite{thrun2005probabilistic}「観測モデル」\cite{上田2019}と呼びます．
観測モデルは式\ref{eq:measurement_model}で表されます．
提案分布に観測モデルを適用してできた分布を「目標分布」もしくは「事後分布」と呼びます．
Probabilistic Roboticsでは，LiDAR等のレーザーセンサのための観測モデルの種類としてビームモデル(\textsf{beam\_range\_finder\_model})と尤度場モデル(\textsf{likelihood\_field\_model})が紹介されています．

\begin{equation}
  p(z_{t} \mid \bm{x}_{t}, m)
  \label{eq:measurement_model}
\end{equation}

\subsection{問題の定式化}

パーティクルフィルタにおいて，$i$番目のパーティクルの重み$w^{(i)}$は式\ref{eq:particle_weight_equation}で更新されます．

\begin{equation}
  w^{(i)} = \frac{p(\bm{x}_{1:t}^{(i)} \mid z_{1:t}, u_{1:t})}{\pi(\bm{x}_{1:t}^{(i)} \mid z_{1:t}, u_{1:t})}
  \label{eq:particle_weight_equation}
\end{equation}

式\ref{eq:particle_weight_equation}右辺の分子は事後分布，分母は提案分布です．
事後分布と提案分布の差が小さい程フィルタの性能は上がりますが，提案分布$\pi$が事後分布と一致することはまずありません．
また，式\ref{eq:particle_weight_equation}のままだと新しい観測が得られる度に各パーティクルの軌跡の重みを評価しなければならないため，時間が経過するにつれて計算負荷は増大していってしまいます．
ここで，提案分布が式\ref{eq:proposal_assumption}に従うと仮定します．

\begin{equation}
  \pi(\bm{x}_{1:t} \mid z_{1:t}, u_{1:t}) = \pi(\bm{x}_{t} \mid \bm{x}_{1:t-1}, z_{1:t}, u_{1:t}) \cdot \pi(\bm{x}_{1:t-1} \mid z_{1:t-1}, u_{1:t-1})
  \label{eq:proposal_assumption}
\end{equation}

式\ref{eq:proposal_assumption}を使って式\ref{eq:particle_weight_equation}を逐次式に変換すると，

\begin{equation}
  \begin{split}
    &w^{(i)} = \frac{p(\bm{x}_{1:t}^{(i)} \mid z_{1:t}, u_{1:t})}{\pi(\bm{x}_{1:t}^{(i)} \mid z_{1:t}, u_{1:t})} \\
    &= \eta \frac{p(z_{1:t} \mid \bm{x}_{1:t}^{(i)}, z_{1:t-1}) p(\bm{x}_{t}^{(i)} \mid \bm{x}_{t-1}^{(i)}, u_{t})}{\pi(\bm{x}_{t}^{(i)} \mid \bm{x}_{1:t-1}^{(i)}, z_{1:t}, u_{1:t})} \cdot \frac{p(\bm{x}_{1:t-1}^{(i)} \mid z_{1:t-1}, u_{1:t-1})}{\pi(\bm{x}_{1:t-1}^{(i)} \mid z_{1:t-1}, u_{1:t-1})} \\
    &= \eta \frac{p(z_{1:t} \mid \bm{x}_{t}^{(i)}, m_{t-1}^{(i)}) p(\bm{x}_{t}^{(i)} \mid \bm{x}_{t-1}^{(i)}, u_{t})}{\pi(\bm{x}_{t}^{(i)} \mid \bm{x}_{1:t-1}^{(i)}, z_{1:t}, u_{1:t}}) w_{t-1}^{(i)}
  \end{split}
  \label{eq:sequential_particle_weight_equation}
\end{equation}

\noindent
となります．ただし，$\eta$は式\ref{eq:sequential_particle_weight_equation}の2段目でベイズの定理を適用して確率分布を分解したときに出てきた正規化因子です．

式\ref{eq:sequential_particle_weight_equation}を使ってパーティクルを更新するためには，提案分布$\pi$からドローしなければなりません．
パーティクルフィルタの性能は提案分布$\pi$で決まり，$\pi$が目標分布に近ければフィルタの性能は向上します．

FastSLAM1.0のような従来型のアルゴリズムでは，この提案分布$\pi$には状態遷移モデル$p(\bm{x}_{t} \mid \bm{x}_{t-1}, u_{t})$が使用されます．
提案分布に状態遷移モデルを使うと，パーティクルの重みの演算が観測モデル$p(z_{t} \mid m, \bm{x}_{t})$だけで行えます．
実際，式\ref{eq:sequential_particle_weight_equation}の$\pi$に状態遷移モデルを代入すると，式\ref{eq:sequential_weight_equation_fastslam1.0}のようになります．

\begin{equation}
  \begin{split}
    &w_{t}^{(i)} = \eta \frac{p(z_{1:t} \mid \bm{x}_{t}^{(i)}, m_{t-1}^{(i)}) p(\bm{x}_{t}^{(i)} \mid \bm{x}_{t-1}^{(i)}, u_{t})}{\pi(\bm{x}_{t}^{(i)} \mid \bm{x}_{1:t-1}^{(i)}, z_{1:t}, u_{1:t}}) w_{t-1}^{(i)} \\
    &= \eta \frac{p(z_{1:t} \mid \bm{x}_{t}^{(i)}, m_{t-1}^{(i)}) p(\bm{x}_{t}^{(i)} \mid \bm{x}_{t-1}^{(i)}, u_{t})}{p(\bm{x}_{t}^{(i)} \mid \bm{x}_{1:t-1}^{(i)}, z_{1:t}, u_{1:t}}) w_{t-1}^{(i)} \\
    &= \eta p(z_{1:t} \mid \bm{x}_{t}^{(i)}, m_{t-1}^{(i)}) w_{t-1}^{(i)}
  \end{split}
  \label{eq:sequential_weight_equation_fastslam1.0}
\end{equation}

ここで，センサによる観測情報の精度が，オドメトリよりも十分に正確な場合を考えます．
このとき，観測モデルの意味のある領域は，オドメトリ動作モデルの範囲に比べて非常に狭くなってしまいます．
1次元で表すと，図\ref{fig:meaningful_area_of_likelihood}のようになります．

\begin{figure}[ht]
  \centering
  \begin{tikzpicture}
    % X Axis
    \draw[->,>=stealth,semithick] (0, 0) -- (6, 0) node[right]{$x$};
    % Y Axis
    \draw[->,>=stealth,semithick] (0, 0) -- (0, 4) node[above]{$y$};
    % Origin
    \draw (0, 0) node[below left]{O};

    % Motion Model Function
    \draw[red, thick, domain=0:6] plot(\x, {exp(-(\x - 3) * (\x - 3) / 2 / 2.0) / sqrt(2*pi*2.0)}) node[right]{};
    % Measurement Model Function
    \draw[thick, domain=1.5:2.5, samples=100] plot(\x, {exp(-(\x - 2) * (\x - 2) / 2 / 0.01) / sqrt(2*pi*0.01)}) node[right]{};
    
    \draw (2.1, 3.5) node[right]{$p(z_{t} \mid \bm{x}_{t}, m_{t-1})$};
    \draw (3, 0.5) node[right]{$p(\bm{x}_{t} \mid \bm{x}_{t-1}, u_{t})$};

    \draw [bend right, distance=0.3cm] (1.5, 0) to node[fill=white, inner sep=0.2pt, circle, below] {$L^{(i)}$} (2.5, 0);
   \end{tikzpicture}
   \caption{The Meaningful Area of the Observation Likelihood}
   \label{fig:meaningful_area_of_likelihood}
\end{figure}

このとき，オドメトリ動作モデルによってばらまかれたパーティクルの内，図\ref{fig:meaningful_area_of_likelihood}に示す観測モデルの意味のある領域$L^{(i)}$をカバーするパーティクルの数は非常に少なくなってしまいます．
$L^{(i)}$を十分な数のパーティクルで近似するには，以下の３つの対策が考えられます．

\begin{enumerate}
  \item 計算に使用するパーティクルの数を増やす
  \item 観測モデルを平滑化して分散を大きくし，$L^{(i)}$を無理やり大きくする
  \item パーティクルを観測に近い方向にばらまく
\end{enumerate}

パーティクルの数を増やせば当然$L^{(i)}$をカバーするパーティクルの数も増えますが，無駄な計算も多くなります．
観測モデルを平滑化して精度を落とせば$L^{(i)}$に近いパーティクルの重みをある程度確保できますが，せっかくのセンサのデータを破棄することにつながります．

というわけで，パーティクルを観測に近い方向にばらまくような提案分布を作れば良いということになります．
GMappingでは提案分布に観測の情報を統合することにより，観測モデルの意味のある領域にパーティクルを集中させる方法を取っています．
すなわち，

\begin{equation}
  p(\bm{x}_{t} \mid m_{t-1}^{(i)}, \bm{x}_{t-1}^{(i)}, z_{t}, u_{t})
  = \frac{p(z_{t} \mid m_{t-1}^{(i)}, \bm{x}_{t})p(\bm{x}_{t} \mid \bm{x}_{t-1}^{(i)}, u_{t-1})}{p(z_{t} \mid m_{t-1}^{(i)}, \bm{x}_{t-1}^{(i)}, u_{t})}
  \label{eq:improved_proposal}
\end{equation}

\noindent
を提案分布として使用します．
式\ref{eq:improved_proposal}を提案分布として使用したとき，パーティクルの重みの計算式は，

\begin{equation}
  \begin{split}
    w_{t}^{(i)} &= \eta \frac{p(z_{1:t} \mid \bm{x}_{t}^{(i)}, m_{t-1}^{(i)}) p(\bm{x}_{t}^{(i)} \mid \bm{x}_{t-1}^{(i)}, u_{t})}{p(\bm{x}_{t} \mid m_{t-1}^{(i)}, \bm{x}_{t-1}^{(i)}, z_{t}, u_{t})) w_{t-1}^{(i)}} \\
    &= \eta \frac{p(z_{1:t} \mid \bm{x}_{t}^{(i)}, m_{t-1}^{(i)}) p(\bm{x}_{t}^{(i)} \mid \bm{x}_{t-1}^{(i)}, u_{t})}{\frac{p(z_{t} \mid m_{t-1}^{(i)}, \bm{x}_{t})p(\bm{x}_{t} \mid \bm{x}_{t-1}^{(i)}, u_{t-1})}{p(z_{t} \mid m_{t-1}^{(i)}, \bm{x}_{t-1}^{(i)}, u_{t})}} \\
    &= \eta p(z_{t} \mid m_{t-1}^{(i)}, \bm{x}_{t-1}^{(i)}, u_{t})w_{t-1}^{(i)} \\
    &= \int p(z_{t} \mid \bm{x}^{\prime})p(\bm{x}^{\prime} \mid \bm{x}_{t-1}^{(i)}, u_{t})d\bm{x}^{\prime} \cdot w_{t-1}^{(i)}
  \end{split}
\end{equation}

\noindent
となります．
特徴ベースのFastSLAM2.0では，この改善された提案分布をガウス分布に近似したものを使用しています．
ランドマークの計測誤差がガウス分布に従うと仮定し，提案分布をカルマンフィルタによってガウス分布に近似します．
一方，GMappingのように占有格子地図を扱うSLAMでは，観測モデルの形状が予想できないため，特徴ベースのようにカルマンフィルタを使って近似するといったことができません．
そこで，GMappingではスキャンマッチングを用いて，状態遷移モデルによってばらまいたパーティクルを尤もらしい位置に補正しています．

まず，状態遷移モデルに従ってパーティクルを遷移させます．
この作業はFastSLAM1.0と変わりません．
次に，センサによって得られた観測情報を使って，状態遷移モデルで移動させたパーティクルを，尤度が高くなる位置に移動させます．
スキャンマッチングを適用した後，分布のガウス近似の中心と分散を求めます．
中心$\mu_{t}^{(i)}$と分散$\Sigma_{t}^{(i)}$の計算式は式\ref{eq:mean_and_covariance}となります．

\begin{equation}
  \begin{cases}
    \mu_{t}^{(i)} = \frac{1}{\eta^{(i)}} \sum_{j = 1}^{K} \bm{x}_{j} \cdot p(z_{t} \mid m_{t-1}^{(i)}, \bm{x}_{j}) \cdot p(\bm{x}_{j} \mid \bm{x}_{t-1}^{(i)}, u_{t}) \\
    \Sigma_{t}^{(i)} = \frac{1}{\eta^{(i)}} \sum_{j = 1}^{K}\bm{x}_{j} \mid m_{t-1}^{(i)}, \bm{x}_{j}) \cdot p(\bm{x}_{j} \mid \bm{x}_{t-1}^{(i)}, u_{t}) \cdot (\bm{x}_{j} - \mu_{t}^{(i)})(\bm{x}_{j} - \mu_{t}^{(i)})^{T}
  \end{cases}
  \label{eq:mean_and_covariance}
\end{equation}

\noindent
ここで，$\eta^{(i)}$は正規化因子で，式\ref{eq:normalized_factor}で計算できます．

\begin{equation}
  \eta^{(i)} = \sum_{j=1}^{K} p(z_{t} \mid m_{t-1}^{(i)}, \bm{x}_{j}) p(\bm{x}_{j} \mid \bm{x}_{t-1}^{(i)}, u_{t})
  \label{eq:normalized_factor}
\end{equation}

このようにすることで，改善された提案分布を求めることができるようになります．
従って，重みの計算式は式\ref{eq:particle_weight_by_improved_proposal}となります．

\begin{equation}
  \begin{split}
    w_{t}^{(i)} &= p(z_{t} \mid m_{t-1}^{(i)}, \bm{x}_{t-1}^{(i)}, u_{t}) w_{t-1}^{(i)} \\
    &= \int p(z_{t} \mid m_{t-1}^{(i)}, \bm{x}^{\prime})p(\bm{x}^{\prime} \mid \bm{x}_{t-1}^{(i)}, u_{t})d\bm{x}^{\prime} w_{t-1}^{(i)}\\
    &\simeq \sum_{j=1}^{K} p(z_{t} \mid m_{t-1}^{(i)}, \bm{x}_{j}) p(\bm{x}_{j} \mid \bm{x}_{t-1}^{(i)}, u_{t}) w_{t-1}^{(i)} \\
    &= \eta^{(i)} w_{t-1}^{(i)}
  \end{split}
  \label{eq:particle_weight_by_improved_proposal}
\end{equation}

実際に計算を行う際は，観測モデル$p(z_{t} \mid \bm{x}_{t}, m_{t-1}^{(i)})$はレーザービームの尤度場モデルが，状態遷移モデル$p(\bm{x}_{t} \mid \bm{x}_{t-1}, u_{t})$にはオドメトリ動作モデルが使われます．
これらのモデルについては次小節以降に説明します．

\subsection{オドメトリ状態遷移モデル}

\subsection{レーザービームの尤度場モデル}

\subsection{リサンプリングアルゴリズム}

\end{document}